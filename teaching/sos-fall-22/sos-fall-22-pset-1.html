<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>sos-fall-22-pset-1</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="../../styling.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h2 id="problem-set-1">Problem Set 1</h2>
<p>Please turn in a PDF of typeset solutions solutions using LaTeX. Please turn in the pset by emailing me this pdf.</p>
<p><em>This pset may have bugs! Please email me, or reach out on Piazza, if you think there is a bug in a problem!</em></p>
<p>Due: October 14, 11:59pm Eastern time.</p>
<p>You may use external resources such as Wikipedia to look up material which would reasonably be a prerequisite for this course (undergraduate-level algebra, linear algebra, probability, etc.). These exercises are designed to teach you something interesting about SoS and to acquaint you with an idea we won’t have time to cover in lecture. As such, solutions to some of them may appear in the research literature or in reference material for this course. Please avoid using such solutions, and if you find you have already read one, please set aside the corresponding problem for a few days before working on it again.</p>
<p><strong>Problem 1, 10 pts</strong> <em>(Size of SoS coefficients)</em>: In lecture 1, we stated, but did not prove, that SoS proofs of nonnegativity over the hypercube can without loss of generality be taken to have coefficients expressible in a small number of bits. This is an important component of the proof that a polynomial-time algorithm using semidefinite programming can find such SoS proofs, if they exist.</p>
<p><em>Part A:</em> Let <span class="math inline">\(f \, : \, \{0,1\}^n \rightarrow \mathbb{R}\)</span> be a Boolean function on <span class="math inline">\(n\)</span> bits, let <span class="math inline">\(d \in \mathbb{N}\)</span> be even, and suppose that <span class="math inline">\(|f(x)| \leq n^{O(d)}\)</span> for all <span class="math inline">\(x\)</span> and that <span class="math inline">\(\vdash_d f \geq 0\)</span>. Show that there are <span class="math inline">\(p_1,\ldots,p_m \in \mathbb{R}[x]_{\leq d}\)</span> with <span class="math inline">\(m \leq n^{O(d)}\)</span> such that the magnitude of every coefficient of each <span class="math inline">\(p_i\)</span> when written as a multilinear polynomial is at most <span class="math inline">\(n^{O(d)}\)</span>.</p>
<details>
<summary>
Hint 1 (click to expand)
</summary>
If <span class="math inline">\(p_1,\ldots,p_m\)</span> witness <span class="math inline">\(\vdash_d f \geq 0\)</span>, then what can we say about the magnitude of <span class="math inline">\(\mathbb E_{x \sim \{0,1\}^n} \sum p_i(x)^2\)</span>?
</details>
<details>
<summary>
Hint 2 (click to expand)
</summary>
Take <span class="math inline">\(p_1,\ldots,p_m\)</span> to be multilinear. Then what does a bound on <span class="math inline">\(\mathbb E_{x \sim \{0,1\}^n} \sum p_i(x)^2\)</span> say about the magnitude of the coefficients of the <span class="math inline">\(p_i\)</span>’s?
</details>
<p><em>Part B:</em> The Ellipsoid algorithm for finding a point in a convex set has the following guarantee. If <span class="math inline">\(\mathcal{C} \subseteq \mathbb{R}^n\)</span> is contained in a ball of radius <span class="math inline">\(R\)</span> and contains a ball of radius <span class="math inline">\(r\)</span>, then Ellipsoid returns a point in <span class="math inline">\(\mathcal{C}\)</span> after <span class="math inline">\((n \log R / r)^{O(1)}\)</span> calls to a separation oracle for <span class="math inline">\(\mathcal{C}\)</span>.</p>
<p>Show that there is a polynomial-time algorithm which takes as input a degree-<span class="math inline">\(d\)</span> function <span class="math inline">\(f \, : \, \{0,1\}^n \rightarrow \mathbb{R}\)</span>, represented as a list of <span class="math inline">\(n^{O(d)}\)</span> rational coefficients of magnitude at most <span class="math inline">\(n^{O(d)}\)</span>, and a parameter <span class="math inline">\(\varepsilon&gt; 0\)</span>, and if <span class="math inline">\(\vdash_d f \geq 0\)</span>, returns a proof <span class="math inline">\(p_1,\ldots,p_m\)</span> witnessing <span class="math inline">\(\vdash_d f + \epsilon \geq 0\)</span>, in time <span class="math inline">\((n^d \cdot \log (1/\varepsilon))^{O(1)}\)</span>.</p>
<p>You may assume that there is a polynomial-time separation oracle for the set of PSD matrices – that is, an algorithm which, given an <span class="math inline">\(N \times N\)</span> matrix <span class="math inline">\(M\)</span> of rationals as input, either certifies that this matrix is PSD or returns a PSD matrix <span class="math inline">\(X\)</span> such that <span class="math inline">\(\langle X,M \rangle &lt; 0\)</span> but <span class="math inline">\(\langle X,P \rangle \geq 0\)</span> for all <span class="math inline">\(P \succeq 0\)</span>.</p>
<p><strong>Problem 2, 10 pts</strong> <em>(Max cut in almost-bipartite graphs):</em> Show that there is a polynomial-time algorithm with the following guarantee: given a graph <span class="math inline">\(G = (V,E)\)</span> such that there is a cut which cuts <span class="math inline">\((1-\varepsilon)|E|\)</span> edges, the algorithm outputs a cut which cuts <span class="math inline">\((1-\tilde{O}(\sqrt{\varepsilon}))|E|\)</span> edges. <span class="math inline">\((\tilde{O}\)</span> can hide factors of <span class="math inline">\(\log(1/\varepsilon)\)</span>, though this is not strictly necessary.)</p>
<p>You may use the following basic anticoncentration fact for Gaussians: if <span class="math inline">\(Z \sim N(0,1)\)</span>, then <span class="math inline">\(Pr(|Z| \leq \delta) = O(\delta)\)</span>.</p>
<details>
<summary>
Hint 1 (click to expand)
</summary>
Use the Gaussian rounding scheme from lecture.
</details>
<details>
<summary>
Hint 2 (click to expand)
</summary>
What is the probability that a 2-variable Gaussian distribution <span class="math inline">\((g,h)\)</span> with <span class="math inline">\(\mathbb Eg^2 = \mathbb Eh^2 = 1\)</span> and <span class="math inline">\(\mathbb E(g-h)^2 \geq 4-\varepsilon\)</span> has <span class="math inline">\(sign(g) \neq sign(h)\)</span>?
</details>
<p><strong>Problem 3, 10 pts</strong> <em>(Max Bisection):</em> Max-bisection is the following optimization problem on graphs. Given a graph <span class="math inline">\(G = (V,E)\)</span>, with <span class="math inline">\(|V|\)</span> an even number, the goal is to find <span class="math display">\[ \max_{S \subset V, |S| = n/2} E(S,\overline{S})\]</span> where <span class="math inline">\(E(S,\overline{S})\)</span> denotes the set of edges crossing the cut <span class="math inline">\((S,\overline{S})\)</span>.</p>
<p>In this exercise, we will see another application of the <em>low global correlation</em> idea to round pseudoexpectations for max bisection. The goal will be to prove the following theorem:</p>
<p><em>Theorem:</em> For every <span class="math inline">\(\varepsilon&gt; 0\)</span>, there is an algorithm running in time <span class="math inline">\(n^{(1/\varepsilon)^{O(1)}}\)</span> which <span class="math inline">\((1+\varepsilon)\)</span>-approximates the max-bisection value in dense graphs.</p>
<p>It turns out that the ideas to prove this result can be combined with an extension of the ideas in Problem 2 to prove the following stronger theorem (which is not conceptually different but requires more technical work to prove): there is a polynomial time algorithm which, given a graph in which the max-bisection value is at least <span class="math inline">\((1-\varepsilon) |E|\)</span>, returns a bisection cutting <span class="math inline">\((1-O(\sqrt{\varepsilon}))|E|\)</span> edges.</p>
<p><em>Constrained pseudoexpectations:</em> You may assume that there is an <span class="math inline">\(n^{O(d)}\)</span>-time algorithm for the following problem: given a graph <span class="math inline">\(G\)</span>, find a pseudoexpectation <span class="math inline">\(\tilde{\mathbb E}\)</span> of degree <span class="math inline">\(d\)</span> maximizing <span class="math inline">\(\tilde{\mathbb E}\sum_{i \sim j} (x_i - x_j)^2\)</span> among all <span class="math inline">\(\tilde{\mathbb E}\)</span> with the following “balance” property: for all polynomials <span class="math inline">\(p\)</span> of degree at most <span class="math inline">\(d-1\)</span>, <span class="math inline">\(\tilde{\mathbb E}p(x) \cdot \sum_{i \leq n} x_i = \tfrac n 2 \tilde{\mathbb E}p(x)\)</span>. (We are ignoring some minor numerical issues here.) Notice that this property would be satisfied by <span class="math inline">\(\mathbb E_\mu p(x)\)</span> for any distribution <span class="math inline">\(\mu\)</span> on bisections; that is, on Boolean vectors with <span class="math inline">\(\sum_{i \leq n} x_i = n/2\)</span>.</p>
<p><em>Part A:</em> Prove that if <span class="math inline">\(\tilde{\mathbb E}\)</span> is a degree-<span class="math inline">\(d\)</span> pseudoexpectation satisfying the balance property above, and if <span class="math inline">\(\tilde{\mathbb E}&#39;\)</span> is the result of conditioning <span class="math inline">\(\tilde{\mathbb E}\)</span> on the values of <span class="math inline">\(t \ll d\)</span> variables, then <span class="math inline">\(\tilde{\mathbb E}&#39;\)</span> also satisfies the balance property.</p>
<p><em>Part B:</em> Consider independent rounding applied to <span class="math inline">\(\tilde{\mathbb E}\)</span> to produce a Boolean vector <span class="math inline">\(y \in \{0,1\}^n\)</span>. Show that if the global information of <span class="math inline">\(\tilde{\mathbb E}\)</span> is <span class="math inline">\(\delta\)</span>, then <span class="math inline">\(Var(\sum y_i) \leq \delta^{\Omega(1)} n^2\)</span>. (In fact, you can even show <span class="math inline">\(Var(\sum y_i) \leq O(n)\)</span>.)</p>
<p><em>Part C:</em> Prove the above theorem on the min-bisection value in dense graphs. You may appeal to any facts from lecture about global information, correlation rounding, etc. Your algorithm may be randomized and should succeed with high probability.</p>
<p><strong>Problem 4, 10 pts</strong> <em>(Fun with SoS Proofs):</em></p>
<p><em>Part A (Cauchy-Schwarz):</em> For every family of degree-<span class="math inline">\(d\)</span> polynomials <span class="math inline">\(p_1(x),\ldots,p_m(x), q_1(x),\ldots,q_m(x)\)</span>, show that <span class="math display">\[\vdash_{4d} (\sum_{i \leq m} p_i(x)^2 )(\sum_{i \leq m} q_i(x)^2) - (\sum_{i \leq m} p_i(x) q_i(x))^2 \geq 0.\]</span></p>
<p><em>Part B (Cauchy-Schwarz, Pseudoexpectation version):</em> Show that for every degree-<span class="math inline">\(d\)</span> pseudoexpectation <span class="math inline">\(\tilde{\mathbb E}\)</span> and every pair of degree <span class="math inline">\(d/2\)</span> polynomials <span class="math inline">\(p,q\)</span>, <span class="math inline">\(\tilde{\mathbb E}pq \leq \sqrt{\tilde{\mathbb E}p^2 \cdot \tilde{\mathbb E}q^2}\)</span>.</p>
<p><em>Part C (Approximate Triangle Inequalities):</em> Show that there is a constant <span class="math inline">\(C\)</span> (indep. of <span class="math inline">\(m\)</span>) such that for vectors of polynomials <span class="math inline">\(p_1(x),\ldots,p_m(x), q_1,(x),\ldots,q_m(x)\)</span>, <span class="math display">\[ \vdash_{O(\max \{ \deg p_i, \deg q_i \}_{i \leq m})} C (\|p\|_2^2 + \|q\|_2^2) - \| p + q \|_2^2 \geq 0\]</span> and in fact for every even <span class="math inline">\(t\)</span>, there is <span class="math inline">\(C_t\)</span> such that <span class="math display">\[ \vdash_{O(t \cdot \max \{ \deg p_i, \deg q_i \}_{i \leq m})} C_t (\|p\|_t^t + \|q\|_t^t) - \|p+q\|_t^t \geq 0.\]</span></p>
<p><strong>Problem 5, 10 pts</strong> <em>(Finding hidden cliques):</em></p>
<p><em>Part A:</em> A random graph <span class="math inline">\(G\)</span> on <span class="math inline">\(n\)</span> vertices (containing each possible edge independently with probability <span class="math inline">\(1/2\)</span>) contains, with high probability, a clique of size <span class="math inline">\((2 -o(1))\log n\)</span>, and no clique larger than <span class="math inline">\((2+ o(1)) \log n\)</span>. But, are there SoS proofs of the latter fact?</p>
<p>Show that the following sort of SoS proof (somwhat different from what we have discussed thus far) exists with high probability over choice of a random <span class="math inline">\(G\)</span>: <span class="math display">\[O(\sqrt n)  - \sum_{i \leq n} x_i = \sum_{i,j \leq n, i \not \sim j} p_{ij}(x) x_i x_j + \sum_{i \leq m} q_i(x)^2, \text{ for all } x \in \{0,1\}^n,\]</span> where <span class="math inline">\(p_{ij}, q_i\)</span> are polynomials of degree at most <span class="math inline">\(O(1)\)</span>, and <span class="math inline">\(i \not \sim j\)</span> means that <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are not adjacent in <span class="math inline">\(G\)</span>.</p>
<p>(First, argue that the existence of such polynomials rules out cliques in <span class="math inline">\(G\)</span> of size <span class="math inline">\(\gg \sqrt n\)</span>.)</p>
<p>You may use the following fact about random graphs. If <span class="math inline">\(G\)</span> is a random graph and <span class="math inline">\(A\)</span> is its adjacency matrix, then with high probability, <span class="math inline">\(\|A - \tfrac 12 11^\top\| \leq O(\sqrt n)\)</span>, where <span class="math inline">\(1\)</span> denotes the all-<span class="math inline">\(1\)</span>s vector.</p>
<p><em>Part B (robustness against monotone adversary):</em> Argue that the same type of SoS proof exists with high probability for a random graph <span class="math inline">\(G\)</span> which has been adversarially perturbed in the following way: observing the graph, a malicious adversary removes (but does not add) an arbitrary set of edges.</p>
<p><em>Part C (recovering a clique):</em> Consider the following <em>planted clique</em> distribution on random graphs: a graph <span class="math inline">\(G\)</span> is sampled uniformly, and then a subset <span class="math inline">\(S\)</span> of vertices of size <span class="math inline">\(k\)</span> is also chosen uniformly at random. Any edges with both endpoints in <span class="math inline">\(S\)</span> are added to <span class="math inline">\(G\)</span>, so that <span class="math inline">\(S\)</span> is a clique in <span class="math inline">\(G\)</span>.</p>
<p>UPDATED: Show that there is a polynomial time algorithm which, with probability at least <span class="math inline">\(0.99\)</span>, finds a subset of <span class="math inline">\(O(\sqrt n)\)</span> vertices of <span class="math inline">\(G\)</span> which contains <span class="math inline">\(99\%\)</span> of <span class="math inline">\(S\)</span>.</p>
<p>OPTIONAL: Show that there is a polynomial-time algorithm which, with probability at least <span class="math inline">\(0.99\)</span>, finds a clique of size <span class="math inline">\(\Omega(\sqrt n)\)</span> in <span class="math inline">\(G\)</span>, assuming <span class="math inline">\(k \geq C\sqrt{n}\)</span> for a large-enough constant <span class="math inline">\(C\)</span>.</p>
<p>Show furthermore that this algorithm still finds <span class="math inline">\(S\)</span> even if a monotone adversary removes any non-clique edges from <span class="math inline">\(G\)</span> before your algorithm receives <span class="math inline">\(G\)</span> as input.</p>
<p>You may assume that there is a polynomial-time algorithm for the following problem: given a graph <span class="math inline">\(G\)</span> and constant <span class="math inline">\(d\)</span>, find a degree-<span class="math inline">\(d\)</span> pseudoexpectation maximizing <span class="math inline">\(\tilde{\mathbb E}\sum_{i \leq n} x_i\)</span> among all <span class="math inline">\(\tilde{\mathbb E}\)</span> with the following property: for each non-edge <span class="math inline">\((i,j)\)</span> in <span class="math inline">\(G\)</span>, and every polynomial <span class="math inline">\(p\)</span> of degree at most <span class="math inline">\(d-2\)</span>, <span class="math inline">\(\tilde{\mathbb E}p(x) \cdot x_i x_j = 0\)</span>. (That is, <span class="math inline">\(\tilde{\mathbb E}\)</span> ``looks like’’ the moments of a distribution supported only on cliques in <span class="math inline">\(G\)</span>.)</p>
<p><em>Explanation:</em> There are less-sophisticated algorithms for finding a planted clique of size <span class="math inline">\(\gg \sqrt n\)</span> in a random <span class="math inline">\(n\)</span>-vertex graph. So, why study the SoS-based algorithm?</p>
<p>Take, for instance, an algorithm based on eigenvectors of the adjacency matrix – it turns out that for <span class="math inline">\(k \gg \sqrt n\)</span>, the top eigenvector of the (centered) adjacency matrix is well-aligned with the indicator vector for the clique (in the non-adversarial case), and this can be used to find the hidden clique. However, this algorithm is in some sense <em>overfit</em> to the random-graph model: the monotone adversary, who intuitively shouldn’t make finding a planted clique harder – after all, she is making the rest of the graph <em>less</em> “clique-y” – can actually make this spectral algorithm fail.</p>
<p>SoS-based algorithms often have appealing robustness guarantees, making the details of the theoretical model in which one analyzes them less important. This is nice, since in real life you rarely know if any assumptions you have made about input data to make some theoretical analysis work actually hold for the data you have in hand.</p>
</body>
</html>
